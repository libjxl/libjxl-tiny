// Copyright (c) the JPEG XL Project Authors.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

#ifndef ENCODER_DCT_SCALES_H_
#define ENCODER_DCT_SCALES_H_

// Scaling factors.

#include <stddef.h>

namespace jxl {

static constexpr float kSqrt2 = 1.41421356237f;

// For n != 0, the n-th basis function of a N-DCT, evaluated in pixel k, has a
// value of cos((k+1/2) n/(2N) pi). When downsampling by 2x, we average
// the values for pixel k and k+1 to get the value for pixel (k/2), thus we get
//
// [cos((k+1/2) n/N pi) + cos((k+3/2) n/N pi)]/2 =
// cos(n/(2N) pi) cos((k+1) n/N pi) =
// cos(n/(2N) pi) cos(((k/2)+1/2) n/(N/2) pi)
//
// which is exactly the same as the value of pixel k/2 of a N/2-sized DCT,
// except for the cos(n/(2N) pi) scaling factor (which does *not*
// depend on the pixel). Thus, when using the lower-frequency coefficients of a
// DCT-N to compute a DCT-(N/2), they should be scaled by this constant. Scaling
// factors for a DCT-(N/4) etc can then be obtained by successive
// multiplications. The structs below contain the above-mentioned scaling
// factors.
//
// Python code for the tables below:
//
// for i in range(N // 8):
//    v = math.cos(i / (2 * N) * math.pi)
//    v *= math.cos(i / (N) * math.pi)
//    v *= math.cos(i / (N / 2) * math.pi)
//    print(v, end=", ")

template <size_t FROM, size_t TO>
struct DCTResampleScales;

template <>
struct DCTResampleScales<8, 1> {
  static constexpr float kScales[] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<16, 2> {
  static constexpr float kScales[] = {
      1.000000000000000000,
      0.901764195028874394,
  };
};

// Inverses of the above.
template <>
struct DCTResampleScales<1, 8> {
  static constexpr float kScales[] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<2, 16> {
  static constexpr float kScales[] = {
      1.000000000000000000,
      1.108937353592731823,
  };
};

// Constants for DCT implementation. Generated by the following snippet:
// for i in range(N // 2):
//    print(1.0 / (2 * math.cos((i + 0.5) * math.pi / N)), end=", ")
template <size_t N>
struct WcMultipliers;

template <>
struct WcMultipliers<4> {
  static constexpr float kMultipliers[] = {
      0.541196100146197,
      1.3065629648763764,
  };
};

template <>
struct WcMultipliers<8> {
  static constexpr float kMultipliers[] = {
      0.5097955791041592,
      0.6013448869350453,
      0.8999762231364156,
      2.5629154477415055,
  };
};

template <>
struct WcMultipliers<16> {
  static constexpr float kMultipliers[] = {
      0.5024192861881557, 0.5224986149396889, 0.5669440348163577,
      0.6468217833599901, 0.7881546234512502, 1.060677685990347,
      1.7224470982383342, 5.101148618689155,
  };
};

// Apply the DCT algorithm-intrinsic constants to DCTResampleScale.
template <size_t FROM, size_t TO>
constexpr float DCTTotalResampleScale(size_t x) {
  return DCTResampleScales<FROM, TO>::kScales[x];
}

}  // namespace jxl

#endif  // ENCODER_DCT_SCALES_H_
